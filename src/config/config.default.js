/**
 * DO NOT EDIT THIS FILE! It is here only for reference.
 * Override/append to these rules by editing ~/.cacher/run-server.user-config.js
 *
 * See https://github.com/cacherapp/cacher-run-server/README.md for complete documentation.
 */



((require) => {
  // Use any standard Node library, along with opn (https://www.npmjs.com/package/opn) and
  // any globally-installed Node packages.
  const path = require('path');
  const childProcess = require('child_process');
  const opn = require('opn');
  const os = require('os');

  return {
    rules: [
      /*
      // Run script for new file extension
      {
        pattern: '\.awesome$',
        run: (command, filepath) => `awesome-compiler "${filepath}"`
      },
      // ------------------------------------------------------
      // Rule to compile .md (Markdown) file into HTML, then display in default browser.
      // Requires first running `npm -g markdown` (https://github.com/evilstreak/markdown-js)
      {
        pattern: '\.md$',
        run: (command, filepath, args) => {
          const outputHtmlFile = `${args.runDir}/${args.baseFilename}.html`;
          childProcess.execSync(`md2html ${filepath} > ${outputHtmlFile}`);
          opn(outputHtmlFile);
          // Must return a shell command
          return `echo "Generated '${outputHtmlFile}'" and opened in default browser`;
        }
      },
      // ------------------------------------------------------
      // Filter file by both filename and content. Run pre-execution command.
      // Put "//nvm: v6.10.1" at top of snippet file to use a specific Node version for execution
      {
        pattern: (command) => {
          return /\.js$/.test(command.file.filename)
            && command.file.content.indexOf('//nvm:') >= 0;
        },
        run: (command, filepath) => {
          let nvmVersion = command.file.content.match(/(\/\/nvm: v(.+))/)[0]
            .replace('//nvm: ', '');
          return `export NVM_DIR=~/.nvm ` +
            `&& source ~/.nvm/nvm.sh` +
            `&& nvm use ${nvmVersion} ` +
            `&& node "${filepath}"`;
        }
      }
      */
    ]
  };
});


const path = require('path');
const opn = require('opn');
const os = require('os');

const IS_WINDOWS = os.platform() === 'win32';
const IS_MAC = os.platform() === 'darwin';
const IS_LINUX = os.platform() === 'linux';

module.exports = {
  version: 1,
  rules: [
    {
      pattern: `\.c$`,
      run: (command, filepath, args) => {
        const outputFile = `${args.runDir}/${args.baseFilename}.out`;
        return `gcc "${filepath}" -o "${outputFile}" && cd "${args.runDir}" && ./"${args.baseFilename}.out"`;
      }
    },
    {
      pattern: '\.clj$',
      run: (command, filepath) => `clojure "${filepath}"`
    },
    {
      pattern: '\.cob$',
      run: (command, filepath, args) => `cd "${args.runDir}" && cobc -x "${filepath}" && ./"${args.baseFilename}"`
    },
    {
      pattern: '\.coffee$',
      run: (command, filepath) => `coffee "${filepath}"`
    },
    {
      pattern: '\.cpp$',
      run: (command, filepath, args) => {
        const outputFile = `${args.runDir}/${args.baseFilename}.out`;
        return `g++ "${filepath}" -o "${outputFile}" && cd "${args.runDir}" && ./"${args.baseFilename}.out"`;
      }
    },
    {
      pattern: '\.cs$',
      timestamp: false,
      run: (command, filepath, args) => {
        return `cd ${args.runDir} && csc.exe ` +
          `/t:exe /out:"${args.baseFilename}.exe" "${args.baseFilename}.cs" && "${args.baseFilename}.exe"`;
      }
    },
    {
      pattern: '\.d$',
      run: (command, filepath) => `rdmd "${filepath}"`
    },
    {
      pattern: '\.dart$',
      run: (command, filepath) => `dart "${filepath}"`
    },
    {
      pattern: '\.elm$',
      run: (command, filepath) => `elm "${filepath}"`
    },
    {
      pattern: '\.exs$',
      run: (command, filepath) => `elixir "${filepath}"`
    },
    {
      pattern: '\.go$',
      run: (command, filepath) => `go run "${filepath}"`
    },
    {
      pattern: '\.groovy$',
      run: (command, filepath) => `groovy "${filepath}"`
    },
    {
      pattern: '\.html$',
      run: (command, filepath) => {
        opn(filepath);
        return `echo "Opened '${command.file.filename}' in default browser"`;
      }
    },
    {
      pattern: '\.hs$',

      run: (command, filepath, args) => `cd "${args.runDir}" && ghc -o "${args.baseFilename}" "${filepath}" && ./"${args.baseFilename}"`
    },
    {
      pattern: '\.hx$',
      timestamp: false,
      run: (command, filepath, args) => `cd "${args.runDir}" && haxe -main "${args.baseFilename}" --interp`
    },
    {
      pattern: '\.java$',
      timestamp: false,
      run: (command, filepath, args) =>
        `cd "${args.runDir}" && javac "${filepath}" && java "${args.baseFilename}"`
    },
    {
      pattern: '\.jl$',
      run: (command, filepath) => `julia "${filepath}"`
    },
    {
      pattern: '\.js$',
      run: (command, filepath) => `node "${filepath}"`
    },
    {
      pattern: '\.kt$',
      run: (command, filepath, args) =>
        `cd "${args.runDir}" && kotlinc "${filepath}" -include-runtime -d "${args.baseFilename}.jar" && java -jar "${args.baseFilename}.jar"`
    },
    {
      pattern: '\.lisp$',
      run: (command, filepath) => `clisp < "${filepath}"`
    },
    {
      pattern: '\.ls$',
      run: (command, filepath) => `lsc "${filepath}"`
    },
    {
      pattern: '\.matlab$',
      // Assumes that `matlab` is in PATH
      run: (command, filepath) => `matlab -nodesktop -nosplash "${filepath}"`
    },
    {
      pattern: '\.ml$',
      run: (command, filepath) => `ocaml "${filepath}"`
    },
    {
      pattern: '\.php$',
      run: (command, filepath) => `php "${filepath}"`
    },
    {
      pattern: '\.pl$',
      run: (command, filepath) => `perl "${filepath}"`
    },
    {
      pattern: '\.ps1$',
      run: (command, filepath) => {
        if (IS_WINDOWS) {
          return `powershell "& ""${filepath}"""`;
        } else {
          return `pwsh "${filepath}"`;
        }
      }
    },
    {
      pattern: '\.py$',
      run: (command, filepath) => `python "${filepath}"`
    },
    {
      pattern: '\.R$',
      run: (command, filepath) => `Rscript "${filepath}"`
    },
    {
      pattern: '\.rb$',
      run: (command, filepath) => `ruby "${filepath}"`
    },
    {
      pattern: '\.rs$',
      run: (command, filepath, args) => {
        const exeFile = path.parse(filepath).name;
        const outputFile = `${args.runDir}/${exeFile}`;
        const isWindows = process.platform === 'win32';
        const runCmd = isWindows ? `.\\"${exeFile}.exe"` : `./"${exeFile}"`;

        return `rustc "${filepath}" -o "${outputFile}" && cd "${args.runDir}" && ${runCmd}`;
      }
    },
    {
      pattern: '\.scala$',
      run: (command, filepath, args) => `cd "${args.runDir}" && scalac "${filepath}" && scala "${args.baseFilename}"`
    },
    {
      pattern: '\.scm$',
      run: (command, filepath) => `scheme --quiet < "${filepath}"`
    },
    {
      pattern: '\.scpt$',
      run: (command, filepath) => `osascript "${filepath}"`
    },
    {
      pattern: '\.sh$',
      run: (command, filepath) => {
        if (IS_WINDOWS) {
          // Need to convert Windows path to WSL bash path
          return `bash -c "bash $(wslpath -a '${filepath}')"`;
        } else {
          return `bash "${filepath}"`;
        }
      }
    },
    {
      pattern: '\.swift$',
      run: (command, filepath) => `swift "${filepath}"`
    },
    {
      pattern: '\.ts$',
      run: (command, filepath, args) => {
        const outputFile = `${args.runDir}/${args.baseFilename}.js`;
        return `tsc "${filepath}" --outFile "${outputFile}" && node "${outputFile}"`;
      }
    },
    {
      pattern: '\.txt$',
      run: (command, filepath) => {
        opn(filepath);
        return `echo "Opened '${command.file.filename}' in default text editor"`;
      }
    }
  ]
const path = require('path');
const opn = require('opn');
const os = require('os');

const IS_WINDOWS = os.platform() === 'win32';
const IS_MAC = os.platform() === 'darwin';
const IS_LINUX = os.platform() === 'linux';

module.exports = {
  version: 1,
  rules: [
    {
      pattern: `\.c$`,
      run: (command, filepath, args) => {
        const outputFile = `${args.runDir}/${args.baseFilename}.out`;
        return `gcc "${filepath}" -o "${outputFile}" && cd "${args.runDir}" && ./"${args.baseFilename}.out"`;
      }
    },
    {
      pattern: '\.clj$',
      run: (command, filepath) => `clojure "${filepath}"`
    },
    {
      pattern: '\.cob$',
      run: (command, filepath, args) => `cd "${args.runDir}" && cobc -x "${filepath}" && ./"${args.baseFilename}"`
    },
    {
      pattern: '\.coffee$',
      run: (command, filepath) => `coffee "${filepath}"`
    },
    {
      pattern: '\.cpp$',
      run: (command, filepath, args) => {
        const outputFile = `${args.runDir}/${args.baseFilename}.out`;
        return `g++ "${filepath}" -o "${outputFile}" && cd "${args.runDir}" && ./"${args.baseFilename}.out"`;
      }
    },
    {
      pattern: '\.cs$',
      timestamp: false,
      run: (command, filepath, args) => {
        return `cd ${args.runDir} && csc.exe ` +
          `/t:exe /out:"${args.baseFilename}.exe" "${args.baseFilename}.cs" && "${args.baseFilename}.exe"`;
      }
    },
    {
      pattern: '\.d$',
      run: (command, filepath) => `rdmd "${filepath}"`
    },
    {
      pattern: '\.dart$',
      run: (command, filepath) => `dart "${filepath}"`
    },
    {
      pattern: '\.elm$',
      run: (command, filepath) => `elm "${filepath}"`
    },
    {
      pattern: '\.exs$',
      run: (command, filepath) => `elixir "${filepath}"`
    },
    {
      pattern: '\.go$',
      run: (command, filepath) => `go run "${filepath}"`
    },
    {
      pattern: '\.groovy$',
      run: (command, filepath) => `groovy "${filepath}"`
    },
    {
      pattern: '\.html$',
      run: (command, filepath) => {
        opn(filepath);
        return `echo "Opened '${command.file.filename}' in default browser"`;
      }
    },
    {
      pattern: '\.hs$',

      run: (command, filepath, args) => `cd "${args.runDir}" && ghc -o "${args.baseFilename}" "${filepath}" && ./"${args.baseFilename}"`
    },
    {
      pattern: '\.hx$',
      timestamp: false,
      run: (command, filepath, args) => `cd "${args.runDir}" && haxe -main "${args.baseFilename}" --interp`
    },
    {
      pattern: '\.java$',
      timestamp: false,
      run: (command, filepath, args) =>
        `cd "${args.runDir}" && javac "${filepath}" && java "${args.baseFilename}"`
    },
    {
      pattern: '\.jl$',
      run: (command, filepath) => `julia "${filepath}"`
    },
    {
      pattern: '\.js$',
      run: (command, filepath) => `node "${filepath}"`
    },
    {
      pattern: '\.kt$',
      run: (command, filepath, args) =>
        `cd "${args.runDir}" && kotlinc "${filepath}" -include-runtime -d "${args.baseFilename}.jar" && java -jar "${args.baseFilename}.jar"`
    },
    {
      pattern: '\.lisp$',
      run: (command, filepath) => `clisp < "${filepath}"`
    },
    {
      pattern: '\.ls$',
      run: (command, filepath) => `lsc "${filepath}"`
    },
    {
      pattern: '\.matlab$',
      // Assumes that `matlab` is in PATH
      run: (command, filepath) => `matlab -nodesktop -nosplash "${filepath}"`
    },
    {
      pattern: '\.ml$',
      run: (command, filepath) => `ocaml "${filepath}"`
    },
    {
      pattern: '\.php$',
      run: (command, filepath) => `php "${filepath}"`
    },
    {
      pattern: '\.pl$',
      run: (command, filepath) => `perl "${filepath}"`
    },
    {
      pattern: '\.ps1$',
      run: (command, filepath) => {
        if (IS_WINDOWS) {
          return `powershell "& ""${filepath}"""`;
        } else {
          return `pwsh "${filepath}"`;
        }
      }
    },
    {
      pattern: '\.py$',
      run: (command, filepath) => `python "${filepath}"`
    },
    {
      pattern: '\.R$',
      run: (command, filepath) => `Rscript "${filepath}"`
    },
    {
      pattern: '\.rb$',
      run: (command, filepath) => `ruby "${filepath}"`
    },
    {
      pattern: '\.rs$',
      run: (command, filepath, args) => {
        const exeFile = path.parse(filepath).name;
        const outputFile = `${args.runDir}/${exeFile}`;
        const isWindows = process.platform === 'win32';
        const runCmd = isWindows ? `.\\"${exeFile}.exe"` : `./"${exeFile}"`;

        return `rustc "${filepath}" -o "${outputFile}" && cd "${args.runDir}" && ${runCmd}`;
      }
    },
    {
      pattern: '\.scala$',
      run: (command, filepath, args) => `cd "${args.runDir}" && scalac "${filepath}" && scala "${args.baseFilename}"`
    },
    {
      pattern: '\.scm$',
      run: (command, filepath) => `scheme --quiet < "${filepath}"`
    },
    {
      pattern: '\.scpt$',
      run: (command, filepath) => `osascript "${filepath}"`
    },
    {
      pattern: '\.sh$',
      run: (command, filepath) => {
        if (IS_WINDOWS) {
          // Need to convert Windows path to WSL bash path
          return `bash -c "bash $(wslpath -a '${filepath}')"`;
        } else {
          return `bash "${filepath}"`;
        }
      }
    },
    {
      pattern: '\.swift$',
      run: (command, filepath) => `swift "${filepath}"`
    },
    {
      pattern: '\.ts$',
      run: (command, filepath, args) => {
        const outputFile = `${args.runDir}/${args.baseFilename}.js`;
        return `tsc "${filepath}" --outFile "${outputFile}" && node "${outputFile}"`;
      }
    },
    {
      pattern: '\.txt$',
      run: (command, filepath) => {
        opn(filepath);
        return `echo "Opened '${command.file.filename}' in default text editor"`;
      }
    }
  ]
};
